// prisma/schema.prisma (version utilisée v5.19.0, la plus stable)
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// --- UTILISATEUR & AUTHENTIFICATION ---
model User {
  id            String    @id @default(uuid())
  firstName     String
  lastName      String  
  email         String    @unique
  phoneNumber   String?   @unique
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Wallet Ryzan (Agent) - L'adresse publique sur Avalanche C-Chain
  walletAddress String?   
  // Note : En prod, on ne stocke jamais la clé privée ici. 
  // Pour le hackathon, on peut la stocker chiffrée ou utiliser un Provider externe.
  
  // Relations
  payments      Payment[]
  transactions  Transaction[]
  recipients    Recipient[]
}

// --- TRANSACTION BLOCKCHAIN (Transfert de fonds) ---
// Sert pour l'historique "Portefeuille" : Envois, Réceptions, Swaps
model Transaction {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  
  amount      Float
  currency    String  @default("USDC") // ex: USDC, AVAX, EURC
  status      String   @default("PENDING") // PENDING, COMPLETED, FAILED
  type        String   // TRANSFER, DEPOSIT, WITHDRAWAL
  
  toAddress   String   // Destinataire
  txHash      String?  // Le hash de la transaction sur Snowtrace (Avalanche)
  
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// --- PAIEMENT X402 (Achat de Services) ---
// C'est le cœur du sujet : L'IA achète l'accès à une ressource (API, Data)
model Payment {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  resourceId  String   // L'ID du service acheté (ex: "premium-weather-data")
  serviceUrl  String?  // L'URL qui a renvoyé le code 402
  
  amount      Float
  currency    String   @default("USDC")
  status      String   @default("UNPAID") // UNPAID, PROCESSING, PAID, FAILED
  
  // La preuve cryptographique (Signature ou TxHash) qui débloque le service
  proof       String?  
  
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Recipient {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  name          String
  walletAddress String
  email         String?
  country       String?  // Code pays (ex: "FR", "IN")
  note          String?
  isFavorite    Boolean  @default(false)

  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, walletAddress]) // Empêche les doublons d'adresse pour un même utilisateur
}